--    This SQL DDL script was generated by Microsoft Visual Studio (Release Date: LOCAL BUILD).

--    Driver Used : Microsoft Visual Studio - Oracle Server Driver.
--    Document    : C:\Users\s13544\Downloads\Atlas_ryb.vsd.
--    Time Created: 9 July 2015 14:46.
--    Operation   : From Visio Generate Wizard.
--    Connected data source : No connection.
--    Connected server      : No connection.
--    Connected database    : Not applicable.




-- Create new table ZARZAD_OKREGU.
-- ZARZAD_OKREGU : Table of Zarzad_okregu
-- 	NICK : Nick partly identifies Zarzad_okregu
-- 	IDOKREGU : IdOkregu partly identifies Zarzad_okregu
-- 	STANOWISKO : Stanowisko is of Zarzad_okregu  
create table ZARZAD_OKREGU (
	NICK VARCHAR2(20) not null,
	IDOKREGU NUMBER(10,0) not null,
	STANOWISKO VARCHAR2(20) not null, constraint ZARZAD_OKREGU_PK primary key (NICK) ); 

-- Create new table OKREGI_PZW.
-- OKREGI_PZW : Table of Okregi_PZW
-- 	IDOKREGU : IdOkregu identifies Okregi_PZW
-- 	NAZWA_OKREGU : Nazwa_okregu is of Okregi_PZW
-- 	ADRES_OKREGU : Adres_okregu is of Okregi_PZW
-- 	CENA : Cena is of Okregi_PZW  
create table OKREGI_PZW (
	IDOKREGU NUMBER(10,0) not null,
	NAZWA_OKREGU VARCHAR2(20) not null,
	ADRES_OKREGU VARCHAR2(20) not null,
	CENA NUMBER(10,0) not null, constraint OKREGI_PZW_PK primary key (IDOKREGU) ); 

-- Create new table REKORD.
-- REKORD : Table of Rekord
-- 	IDRYBY : IdRyby identyfikuje Rekord
-- 	NICK : Nick czêœciowo identyfikuje Rekord
-- 	DLUGOSC : Dlugosc z Rekord
-- 	WAGA : Waga z Rekord
-- 	DATA : Data partly identifies Rekord  
create table REKORD (
	IDRYBY NUMBER(10,0) not null,
	NICK VARCHAR2(20) not null,
	DLUGOSC NUMBER(10,0) not null,
	WAGA NUMBER(10,0) not null,
	DATA DATE not null, constraint REKORD_PK primary key (IDRYBY, NICK, DATA) ); 

-- Create new table UZYTKOWNIK.
-- UZYTKOWNIK : Table of Uzytkownik
-- 	NICK : Nick identyfikuje Uzytkownik
-- 	IMIE : Imie z Uzytkownik
-- 	NAZWISKO : Nazwisko z Uzytkownik
-- 	ROK_URODZENIA : Rok_urodzenia is of Uzytkownik
-- 	ADRES : Adres z Uzytkownik
-- 	TELEFON_UZYTKOWNIKA : Telefon_uzytkownika z Uzytkownik
-- 	ULUBIONA_RYBA : Ulubiona_ryba z Uzytkownik
-- 	ULUBIONA_PRZYNETA : Ulubiona_przyneta z Uzytkownik
-- 	ULUBIONA_LOWISKO : Ulubiona_lowisko z Uzytkownik
-- 	NR_KARTY_RYBACKIEJ : Nr_karty_rybackiej is of Uzytkownik
-- 	KARTA_WAZNA_DO : Karta_wazna_do is of Uzytkownik  
create table UZYTKOWNIK (
	NICK VARCHAR2(20) not null,
	IMIE VARCHAR2(20) not null,
	NAZWISKO VARCHAR2(20) not null,
	ROK_URODZENIA DATE not null,
	ADRES VARCHAR2(30) null,
	TELEFON_UZYTKOWNIKA NUMBER(10,0) null,
	ULUBIONA_RYBA NUMBER(10,0) null,
	ULUBIONA_PRZYNETA NUMBER(10,0) null,
	ULUBIONA_LOWISKO NUMBER(10,0) null,
	NR_KARTY_RYBACKIEJ NUMBER(10,0) not null,
	KARTA_WAZNA_DO DATE not null, constraint UZYTKOWNIK_PK primary key (NICK) ); 

-- Create new table BIERZE_NA.
-- BIERZE_NA : Table of Bierze_na
-- 	IDPRZYNETY : IdPrzynety partly identifies Bierze_na
-- 	IDRYBY : IdRyby identyfikuje Bierze_na  
create table BIERZE_NA (
	IDPRZYNETY NUMBER(10,0) not null,
	IDRYBY NUMBER(10,0) not null, constraint BIERZE_NA_PK primary key (IDPRZYNETY, IDRYBY) ); 

-- Create new table WYSTEPUJE_W.
-- WYSTEPUJE_W : Table of Wystepuje_w
-- 	IDLOWISKA : IdLowiska partly identifies Wystepuje_w
-- 	IDRYBY : IdRyby partly identifies Wystepuje_w  
create table WYSTEPUJE_W (
	IDLOWISKA NUMBER(10,0) not null,
	IDRYBY NUMBER(10,0) not null, constraint WYSTEPUJE_W_PK primary key (IDLOWISKA, IDRYBY) ); 

-- Create new table OCHRONA.
-- OCHRONA : Table of Ochrona
-- 	IDOCHRONY : IdOchrony identyfikuje Ochrona
-- 	DLUGOSC_OCHRONNA : Dlugosc_ochronna z Ochrona
-- 	OKRES_OCHRONNY : Okres_ochronny z Ochrona
-- 	DZIENNY_LIMIT : Dzienny_limit z Ochrona  
create table OCHRONA (
	IDOCHRONY NUMBER(10,0) not null,
	DLUGOSC_OCHRONNA VARCHAR2(20) not null,
	OKRES_OCHRONNY VARCHAR2(30) not null,
	DZIENNY_LIMIT VARCHAR2(20) null, constraint OCHRONA_PK primary key (IDOCHRONY) ); 

-- Create new table PRZYNETA.
-- PRZYNETA : Table of Przyneta
-- 	IDPRZYNETY : IdPrzynety identyfikuje Przyneta
-- 	RODZAJ_PRZYNETY : Rodzaj_przynety z Przyneta  
create table PRZYNETA (
	IDPRZYNETY NUMBER(10,0) not null,
	RODZAJ_PRZYNETY VARCHAR2(20) not null, constraint PRZYNETA_PK primary key (IDPRZYNETY) ); 

-- Create new table LOWISKO.
-- LOWISKO : Table of Lowisko
-- 	IDLOWISKA : IdLowiska identyfikuje Lowisko
-- 	NAZWA_LOWISKA : Nazwa_lowiska z Lowisko
-- 	RODZAJ_LOWISKA : Rodzaj_lowiska z Lowisko
-- 	RODZAJ_WODY : Rodzaj_wody z Lowisko
-- 	ADRES : Adres z Lowisko
-- 	TELEFON : Telefon z Lowisko  
create table LOWISKO (
	IDLOWISKA NUMBER(10,0) not null,
	NAZWA_LOWISKA VARCHAR2(20) not null,
	RODZAJ_LOWISKA VARCHAR2(20) not null,
	RODZAJ_WODY VARCHAR2(20) not null,
	ADRES VARCHAR2(30) not null,
	TELEFON VARCHAR2(20) null, constraint LOWISKO_PK primary key (IDLOWISKA) ); 

-- Create new table RYBA.
-- RYBA : Table of Ryba
-- 	IDRYBY : IdRyby identyfikuje Ryba
-- 	NAZWA : Nazwa is of Ryba
-- 	NAZWA_LACINSKA : Nazwa_lacinska z Ryba
-- 	RODZINA_RYB : Rodzina_ryb z Ryba
-- 	MAX_DLUGOSC : Max_dlugosc z Ryba
-- 	MAX_WAGA : Max_waga z Ryba
-- 	IDOCHRONY : IdOchrony is of Ryba  
create table RYBA (
	IDRYBY NUMBER(10,0) not null,
	NAZWA VARCHAR2(20) not null,
	NAZWA_LACINSKA VARCHAR2(20) not null,
	RODZINA_RYB VARCHAR2(20) not null,
	MAX_DLUGOSC NUMBER(10,0) not null,
	MAX_WAGA VARCHAR2(20) not null,
	IDOCHRONY NUMBER(10,0) null, constraint RYBA_PK primary key (IDRYBY) ); 

-- Add foreign key constraints to table ZARZAD_OKREGU.
alter table ZARZAD_OKREGU
	add constraint UZYTKOWNIK_ZARZAD_OKREGU_FK1 foreign key (
		NICK)
	 references UZYTKOWNIK (
		NICK) DISABLE; 

alter table ZARZAD_OKREGU
	add constraint OKREGI_PZW_ZARZAD_OKREGU_FK1 foreign key (
		IDOKREGU)
	 references OKREGI_PZW (
		IDOKREGU) DISABLE; 

-- Add foreign key constraints to table REKORD.
alter table REKORD
	add constraint RYBA_REKORD_FK1 foreign key (
		IDRYBY)
	 references RYBA (
		IDRYBY) DISABLE; 

alter table REKORD
	add constraint UZYTKOWNIK_REKORD_FK1 foreign key (
		NICK)
	 references UZYTKOWNIK (
		NICK) DISABLE; 

-- Add foreign key constraints to table UZYTKOWNIK.
alter table UZYTKOWNIK
	add constraint RYBA_UZYTKOWNIK_FK1 foreign key (
		ULUBIONA_RYBA)
	 references RYBA (
		IDRYBY) DISABLE; 

alter table UZYTKOWNIK
	add constraint PRZYNETA_UZYTKOWNIK_FK1 foreign key (
		ULUBIONA_PRZYNETA)
	 references PRZYNETA (
		IDPRZYNETY) DISABLE; 

alter table UZYTKOWNIK
	add constraint LOWISKO_UZYTKOWNIK_FK1 foreign key (
		ULUBIONA_LOWISKO)
	 references LOWISKO (
		IDLOWISKA) DISABLE; 

-- Add foreign key constraints to table BIERZE_NA.
alter table BIERZE_NA
	add constraint RYBA_BIERZE_NA_FK1 foreign key (
		IDRYBY)
	 references RYBA (
		IDRYBY) DISABLE; 

alter table BIERZE_NA
	add constraint PRZYNETA_BIERZE_NA_FK1 foreign key (
		IDPRZYNETY)
	 references PRZYNETA (
		IDPRZYNETY) DISABLE; 

-- Add foreign key constraints to table WYSTEPUJE_W.
alter table WYSTEPUJE_W
	add constraint RYBA_WYSTEPUJE_W_FK1 foreign key (
		IDRYBY)
	 references RYBA (
		IDRYBY) DISABLE; 

alter table WYSTEPUJE_W
	add constraint LOWISKO_WYSTEPUJE_W_FK1 foreign key (
		IDLOWISKA)
	 references LOWISKO (
		IDLOWISKA) DISABLE; 

-- Add foreign key constraints to table RYBA.
alter table RYBA
	add constraint OCHRONA_RYBA_FK1 foreign key (
		IDOCHRONY)
	 references OCHRONA (
		IDOCHRONY) DISABLE; 

--Before Update/Insert Validate Foreign Key.
create trigger VALIDATEFK_E59AF96B
before insert or update on ZARZAD_OKREGU
referencing OLD as old NEW as new
for each row when (
	new.NICK IS NOT NULL )
declare
	pk_not_found EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	parent_row UZYTKOWNIK%ROWTYPE;
	cursor c1 (fkVal1 VARCHAR2) is
		SELECT *
		FROM UZYTKOWNIK WHERE
			NICK = fkVal1
		for update of
			NICK;
begin
	open c1(:new.NICK);
	fetch c1 into parent_row;
	if c1%NOTFOUND then
		raise pk_not_found;
	end if;
	close c1;
exception
	when pk_not_found then
		close c1;
		raise_application_error(-20000,'Invalid FK value');
	when mutating_table then
		NULL;
	when others then
		close c1;
		raise;
end;

-- Trigger: Cascade updates to child table.
create trigger ONUPDATECASCADE_DA65E5E4
after update of NICK on UZYTKOWNIK
referencing OLD as old NEW as new
for each row
begin
	UPDATE ZARZAD_OKREGU
	SET
		ZARZAD_OKREGU.NICK = :new.NICK
	WHERE
		ZARZAD_OKREGU.NICK = :old.NICK;
end;

-- Trigger: Cascade deletes to child table.
create trigger ONDELETECASCADE_DA65E5E4
after delete on UZYTKOWNIK
for each row
begin
	DELETE FROM ZARZAD_OKREGU WHERE
		ZARZAD_OKREGU.NICK = :OLD.NICK;
end;

--Before Update/Insert Validate Foreign Key.
create trigger VALIDATEFK_EE92F96B
before insert or update on ZARZAD_OKREGU
referencing OLD as old NEW as new
for each row when (
	new.IDOKREGU IS NOT NULL )
declare
	pk_not_found EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	parent_row OKREGI_PZW%ROWTYPE;
	cursor c1 (fkVal1 NUMBERPS) is
		SELECT *
		FROM OKREGI_PZW WHERE
			IDOKREGU = fkVal1
		for update of
			IDOKREGU;
begin
	open c1(:new.IDOKREGU);
	fetch c1 into parent_row;
	if c1%NOTFOUND then
		raise pk_not_found;
	end if;
	close c1;
exception
	when pk_not_found then
		close c1;
		raise_application_error(-20000,'Invalid FK value');
	when mutating_table then
		NULL;
	when others then
		close c1;
		raise;
end;

-- Trigger: Cascade updates to child table.
create trigger ONUPDATECASCADE_6E9219DF
after update of IDOKREGU on OKREGI_PZW
referencing OLD as old NEW as new
for each row
begin
	UPDATE ZARZAD_OKREGU
	SET
		ZARZAD_OKREGU.IDOKREGU = :new.IDOKREGU
	WHERE
		ZARZAD_OKREGU.IDOKREGU = :old.IDOKREGU;
end;

-- Trigger: Cascade deletes to child table.
create trigger ONDELETECASCADE_6E9219DF
after delete on OKREGI_PZW
for each row
begin
	DELETE FROM ZARZAD_OKREGU WHERE
		ZARZAD_OKREGU.IDOKREGU = :OLD.IDOKREGU;
end;

--Before Update/Insert Validate Foreign Key.
create trigger VALIDATEFK_E449007
before insert or update on REKORD
referencing OLD as old NEW as new
for each row when (
	new.IDRYBY IS NOT NULL )
declare
	pk_not_found EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	parent_row RYBA%ROWTYPE;
	cursor c1 (fkVal1 NUMBERPS) is
		SELECT *
		FROM RYBA WHERE
			IDRYBY = fkVal1
		for update of
			IDRYBY;
begin
	open c1(:new.IDRYBY);
	fetch c1 into parent_row;
	if c1%NOTFOUND then
		raise pk_not_found;
	end if;
	close c1;
exception
	when pk_not_found then
		close c1;
		raise_application_error(-20000,'Invalid FK value');
	when mutating_table then
		NULL;
	when others then
		close c1;
		raise;
end;

-- Trigger: Cascade updates to child table.
create trigger ONUPDATECASCADE_3E19007
after update of IDRYBY on RYBA
referencing OLD as old NEW as new
for each row
begin
	UPDATE REKORD
	SET
		REKORD.IDRYBY = :new.IDRYBY
	WHERE
		REKORD.IDRYBY = :old.IDRYBY;
end;

-- Trigger: Cascade deletes to child table.
create trigger ONDELETECASCADE_3E19007
after delete on RYBA
for each row
begin
	DELETE FROM REKORD WHERE
		REKORD.IDRYBY = :OLD.IDRYBY;
end;

--Before Update/Insert Validate Foreign Key.
create trigger VALIDATEFK_6F0B2FFB
before insert or update on REKORD
referencing OLD as old NEW as new
for each row when (
	new.NICK IS NOT NULL )
declare
	pk_not_found EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	parent_row UZYTKOWNIK%ROWTYPE;
	cursor c1 (fkVal1 VARCHAR2) is
		SELECT *
		FROM UZYTKOWNIK WHERE
			NICK = fkVal1
		for update of
			NICK;
begin
	open c1(:new.NICK);
	fetch c1 into parent_row;
	if c1%NOTFOUND then
		raise pk_not_found;
	end if;
	close c1;
exception
	when pk_not_found then
		close c1;
		raise_application_error(-20000,'Invalid FK value');
	when mutating_table then
		NULL;
	when others then
		close c1;
		raise;
end;

-- Trigger: Cascade updates to child table.
create trigger ONUPDATECASCADE_A7B4D037
after update of NICK on UZYTKOWNIK
referencing OLD as old NEW as new
for each row
begin
	UPDATE REKORD
	SET
		REKORD.NICK = :new.NICK
	WHERE
		REKORD.NICK = :old.NICK;
end;

-- Trigger: Cascade deletes to child table.
create trigger ONDELETECASCADE_A7B4D037
after delete on UZYTKOWNIK
for each row
begin
	DELETE FROM REKORD WHERE
		REKORD.NICK = :OLD.NICK;
end;

--Before Update/Insert Validate Foreign Key.
create trigger VALIDATEFK_299B69DB
before insert or update on UZYTKOWNIK
referencing OLD as old NEW as new
for each row when (
	new.ULUBIONA_RYBA IS NOT NULL )
declare
	pk_not_found EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	parent_row RYBA%ROWTYPE;
	cursor c1 (fkVal1 NUMBERPS) is
		SELECT *
		FROM RYBA WHERE
			IDRYBY = fkVal1
		for update of
			IDRYBY;
begin
	open c1(:new.ULUBIONA_RYBA);
	fetch c1 into parent_row;
	if c1%NOTFOUND then
		raise pk_not_found;
	end if;
	close c1;
exception
	when pk_not_found then
		close c1;
		raise_application_error(-20000,'Invalid FK value');
	when mutating_table then
		NULL;
	when others then
		close c1;
		raise;
end;

-- Trigger: Cascade updates to child table.
create trigger ONUPDATECASCADE_C1E49628
after update of IDRYBY on RYBA
referencing OLD as old NEW as new
for each row
begin
	UPDATE UZYTKOWNIK
	SET
		UZYTKOWNIK.ULUBIONA_RYBA = :new.IDRYBY
	WHERE
		UZYTKOWNIK.ULUBIONA_RYBA = :old.IDRYBY;
end;

-- Trigger: Cascade deletes to child table.
create trigger ONDELETECASCADE_C1E49628
after delete on RYBA
for each row
begin
	DELETE FROM UZYTKOWNIK WHERE
		UZYTKOWNIK.ULUBIONA_RYBA = :OLD.IDRYBY;
end;

--Before Update/Insert Validate Foreign Key.
create trigger VALIDATEFK_669A96EA
before insert or update on UZYTKOWNIK
referencing OLD as old NEW as new
for each row when (
	new.ULUBIONA_PRZYNETA IS NOT NULL )
declare
	pk_not_found EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	parent_row PRZYNETA%ROWTYPE;
	cursor c1 (fkVal1 NUMBERPS) is
		SELECT *
		FROM PRZYNETA WHERE
			IDPRZYNETY = fkVal1
		for update of
			IDPRZYNETY;
begin
	open c1(:new.ULUBIONA_PRZYNETA);
	fetch c1 into parent_row;
	if c1%NOTFOUND then
		raise pk_not_found;
	end if;
	close c1;
exception
	when pk_not_found then
		close c1;
		raise_application_error(-20000,'Invalid FK value');
	when mutating_table then
		NULL;
	when others then
		close c1;
		raise;
end;

-- Trigger: Cascade updates to child table.
create trigger ONUPDATECASCADE_D6569E9
after update of IDPRZYNETY on PRZYNETA
referencing OLD as old NEW as new
for each row
begin
	UPDATE UZYTKOWNIK
	SET
		UZYTKOWNIK.ULUBIONA_PRZYNETA = :new.IDPRZYNETY
	WHERE
		UZYTKOWNIK.ULUBIONA_PRZYNETA = :old.IDPRZYNETY;
end;

-- Trigger: Cascade deletes to child table.
create trigger ONDELETECASCADE_D6569E9
after delete on PRZYNETA
for each row
begin
	DELETE FROM UZYTKOWNIK WHERE
		UZYTKOWNIK.ULUBIONA_PRZYNETA = :OLD.IDPRZYNETY;
end;

--Before Update/Insert Validate Foreign Key.
create trigger VALIDATEFK_B3729649
before insert or update on UZYTKOWNIK
referencing OLD as old NEW as new
for each row when (
	new.ULUBIONA_LOWISKO IS NOT NULL )
declare
	pk_not_found EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	parent_row LOWISKO%ROWTYPE;
	cursor c1 (fkVal1 NUMBERPS) is
		SELECT *
		FROM LOWISKO WHERE
			IDLOWISKA = fkVal1
		for update of
			IDLOWISKA;
begin
	open c1(:new.ULUBIONA_LOWISKO);
	fetch c1 into parent_row;
	if c1%NOTFOUND then
		raise pk_not_found;
	end if;
	close c1;
exception
	when pk_not_found then
		close c1;
		raise_application_error(-20000,'Invalid FK value');
	when mutating_table then
		NULL;
	when others then
		close c1;
		raise;
end;

-- Trigger: Cascade updates to child table.
create trigger ONUPDATECASCADE_CE8D69DA
after update of IDLOWISKA on LOWISKO
referencing OLD as old NEW as new
for each row
begin
	UPDATE UZYTKOWNIK
	SET
		UZYTKOWNIK.ULUBIONA_LOWISKO = :new.IDLOWISKA
	WHERE
		UZYTKOWNIK.ULUBIONA_LOWISKO = :old.IDLOWISKA;
end;

-- Trigger: Cascade deletes to child table.
create trigger ONDELETECASCADE_CE8D69DA
after delete on LOWISKO
for each row
begin
	DELETE FROM UZYTKOWNIK WHERE
		UZYTKOWNIK.ULUBIONA_LOWISKO = :OLD.IDLOWISKA;
end;

--Before Update/Insert Validate Foreign Key.
create trigger VALIDATEFK_27CDEFD4
before insert or update on BIERZE_NA
referencing OLD as old NEW as new
for each row when (
	new.IDRYBY IS NOT NULL )
declare
	pk_not_found EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	parent_row RYBA%ROWTYPE;
	cursor c1 (fkVal1 NUMBERPS) is
		SELECT *
		FROM RYBA WHERE
			IDRYBY = fkVal1
		for update of
			IDRYBY;
begin
	open c1(:new.IDRYBY);
	fetch c1 into parent_row;
	if c1%NOTFOUND then
		raise pk_not_found;
	end if;
	close c1;
exception
	when pk_not_found then
		close c1;
		raise_application_error(-20000,'Invalid FK value');
	when mutating_table then
		NULL;
	when others then
		close c1;
		raise;
end;

-- Trigger: Cascade updates to child table.
create trigger ONUPDATECASCADE_1F0DEFD7
after update of IDRYBY on RYBA
referencing OLD as old NEW as new
for each row
begin
	UPDATE BIERZE_NA
	SET
		BIERZE_NA.IDRYBY = :new.IDRYBY
	WHERE
		BIERZE_NA.IDRYBY = :old.IDRYBY;
end;

-- Trigger: Cascade deletes to child table.
create trigger ONDELETECASCADE_1F0DEFD7
after delete on RYBA
for each row
begin
	DELETE FROM BIERZE_NA WHERE
		BIERZE_NA.IDRYBY = :OLD.IDRYBY;
end;

--Before Update/Insert Validate Foreign Key.
create trigger VALIDATEFK_834D101A
before insert or update on BIERZE_NA
referencing OLD as old NEW as new
for each row when (
	new.IDPRZYNETY IS NOT NULL )
declare
	pk_not_found EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	parent_row PRZYNETA%ROWTYPE;
	cursor c1 (fkVal1 NUMBERPS) is
		SELECT *
		FROM PRZYNETA WHERE
			IDPRZYNETY = fkVal1
		for update of
			IDPRZYNETY;
begin
	open c1(:new.IDPRZYNETY);
	fetch c1 into parent_row;
	if c1%NOTFOUND then
		raise pk_not_found;
	end if;
	close c1;
exception
	when pk_not_found then
		close c1;
		raise_application_error(-20000,'Invalid FK value');
	when mutating_table then
		NULL;
	when others then
		close c1;
		raise;
end;

-- Trigger: Cascade updates to child table.
create trigger ONUPDATECASCADE_F94D1037
after update of IDPRZYNETY on PRZYNETA
referencing OLD as old NEW as new
for each row
begin
	UPDATE BIERZE_NA
	SET
		BIERZE_NA.IDPRZYNETY = :new.IDPRZYNETY
	WHERE
		BIERZE_NA.IDPRZYNETY = :old.IDPRZYNETY;
end;

-- Trigger: Cascade deletes to child table.
create trigger ONDELETECASCADE_F94D1037
after delete on PRZYNETA
for each row
begin
	DELETE FROM BIERZE_NA WHERE
		BIERZE_NA.IDPRZYNETY = :OLD.IDPRZYNETY;
end;

--Before Update/Insert Validate Foreign Key.
create trigger VALIDATEFK_5A4FED56
before insert or update on WYSTEPUJE_W
referencing OLD as old NEW as new
for each row when (
	new.IDRYBY IS NOT NULL )
declare
	pk_not_found EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	parent_row RYBA%ROWTYPE;
	cursor c1 (fkVal1 NUMBERPS) is
		SELECT *
		FROM RYBA WHERE
			IDRYBY = fkVal1
		for update of
			IDRYBY;
begin
	open c1(:new.IDRYBY);
	fetch c1 into parent_row;
	if c1%NOTFOUND then
		raise pk_not_found;
	end if;
	close c1;
exception
	when pk_not_found then
		close c1;
		raise_application_error(-20000,'Invalid FK value');
	when mutating_table then
		NULL;
	when others then
		close c1;
		raise;
end;

-- Trigger: Cascade updates to child table.
create trigger ONUPDATECASCADE_83CFED68
after update of IDRYBY on RYBA
referencing OLD as old NEW as new
for each row
begin
	UPDATE WYSTEPUJE_W
	SET
		WYSTEPUJE_W.IDRYBY = :new.IDRYBY
	WHERE
		WYSTEPUJE_W.IDRYBY = :old.IDRYBY;
end;

-- Trigger: Cascade deletes to child table.
create trigger ONDELETECASCADE_83CFED68
after delete on RYBA
for each row
begin
	DELETE FROM WYSTEPUJE_W WHERE
		WYSTEPUJE_W.IDRYBY = :OLD.IDRYBY;
end;

--Before Update/Insert Validate Foreign Key.
create trigger VALIDATEFK_2D1C1362
before insert or update on WYSTEPUJE_W
referencing OLD as old NEW as new
for each row when (
	new.IDLOWISKA IS NOT NULL )
declare
	pk_not_found EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	parent_row LOWISKO%ROWTYPE;
	cursor c1 (fkVal1 NUMBERPS) is
		SELECT *
		FROM LOWISKO WHERE
			IDLOWISKA = fkVal1
		for update of
			IDLOWISKA;
begin
	open c1(:new.IDLOWISKA);
	fetch c1 into parent_row;
	if c1%NOTFOUND then
		raise pk_not_found;
	end if;
	close c1;
exception
	when pk_not_found then
		close c1;
		raise_application_error(-20000,'Invalid FK value');
	when mutating_table then
		NULL;
	when others then
		close c1;
		raise;
end;

-- Trigger: Cascade updates to child table.
create trigger ONUPDATECASCADE_9D1C128C
after update of IDLOWISKA on LOWISKO
referencing OLD as old NEW as new
for each row
begin
	UPDATE WYSTEPUJE_W
	SET
		WYSTEPUJE_W.IDLOWISKA = :new.IDLOWISKA
	WHERE
		WYSTEPUJE_W.IDLOWISKA = :old.IDLOWISKA;
end;

-- Trigger: Cascade deletes to child table.
create trigger ONDELETECASCADE_9D1C128C
after delete on LOWISKO
for each row
begin
	DELETE FROM WYSTEPUJE_W WHERE
		WYSTEPUJE_W.IDLOWISKA = :OLD.IDLOWISKA;
end;

--Before Update/Insert Validate Foreign Key.
create trigger VALIDATEFK_7CA0357
before insert or update on RYBA
referencing OLD as old NEW as new
for each row when (
	new.IDOCHRONY IS NOT NULL )
declare
	pk_not_found EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	parent_row OCHRONA%ROWTYPE;
	cursor c1 (fkVal1 NUMBERPS) is
		SELECT *
		FROM OCHRONA WHERE
			IDOCHRONY = fkVal1
		for update of
			IDOCHRONY;
begin
	open c1(:new.IDOCHRONY);
	fetch c1 into parent_row;
	if c1%NOTFOUND then
		raise pk_not_found;
	end if;
	close c1;
exception
	when pk_not_found then
		close c1;
		raise_application_error(-20000,'Invalid FK value');
	when mutating_table then
		NULL;
	when others then
		close c1;
		raise;
end;

-- Trigger: Cascade updates to child table.
create trigger ONUPDATECASCADE_370A0357
after update of IDOCHRONY on OCHRONA
referencing OLD as old NEW as new
for each row
begin
	UPDATE RYBA
	SET
		RYBA.IDOCHRONY = :new.IDOCHRONY
	WHERE
		RYBA.IDOCHRONY = :old.IDOCHRONY;
end;

-- Trigger: Cascade deletes to child table.
create trigger ONDELETECASCADE_370A0357
after delete on OCHRONA
for each row
begin
	DELETE FROM RYBA WHERE
		RYBA.IDOCHRONY = :OLD.IDOCHRONY;
end;


-- This is the end of the Microsoft Visual Studio generated SQL DDL script.
